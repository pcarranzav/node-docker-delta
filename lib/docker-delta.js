// Generated by CoffeeScript 1.12.2
(function() {
  var DELTA_OUT_OF_SYNC_CODES, Docker, OutOfSyncError, Promise, TypedError, btrfs, bufIndexOfByte, docker, hardlinkCopy, nullDisposer, parseDeltaStream, path, rsync, spawn, stream, utils,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  path = require('path');

  spawn = require('child_process').spawn;

  Promise = require('bluebird');

  stream = require('readable-stream');

  TypedError = require('typed-error');

  rsync = require('./rsync');

  btrfs = require('./btrfs');

  utils = require('./utils');

  Docker = require('docker-toolbelt');

  docker = new Docker();

  DELTA_OUT_OF_SYNC_CODES = [23, 24];

  exports.OutOfSyncError = OutOfSyncError = (function(superClass) {
    extend(OutOfSyncError, superClass);

    function OutOfSyncError() {
      return OutOfSyncError.__super__.constructor.apply(this, arguments);
    }

    return OutOfSyncError;

  })(TypedError);

  exports.createDelta = function(srcImage, destImage, v2) {
    var config, deltaStream, rsyncStream;
    if (v2 == null) {
      v2 = true;
    }
    deltaStream = new stream.PassThrough();
    rsyncStream = Promise.resolve([srcImage, destImage]).bind(docker).map(docker.imageRootDir).map(function(rootDir) {
      return path.join(rootDir, '/');
    }).spread(rsync.createRsyncStream);
    config = docker.getImage(destImage).inspectAsync().get('Config');
    Promise.all([config, rsyncStream]).spread(function(config, rsyncStream) {
      var metadata;
      if (v2) {
        metadata = {
          version: 2,
          dockerConfig: config
        };
        deltaStream.write(JSON.stringify(metadata));
        deltaStream.write(new Buffer([0x00]));
      }
      return rsyncStream.pipe(deltaStream);
    })["catch"](function(e) {
      return deltaStream.emit('error', e);
    });
    return deltaStream;
  };

  bufIndexOfByte = function(buf, byte) {
    var b, i, j, len;
    for (i = j = 0, len = buf.length; j < len; i = ++j) {
      b = buf[i];
      if (b === byte) {
        return i;
      }
    }
    return -1;
  };

  parseDeltaStream = function(input) {
    return new Promise(function(resolve, reject) {
      var buf, parser;
      buf = new Buffer(0);
      parser = function() {
        var chunk, chunks, e, metadata, sep;
        chunks = [buf];
        while (chunk = input.read()) {
          chunks.push(chunk);
        }
        buf = Buffer.concat(chunks);
        sep = bufIndexOfByte(buf, 0x00);
        if (sep !== -1) {
          input.removeListener('readable', parser);
          input.unshift(buf.slice(sep + 1));
          try {
            metadata = JSON.parse(buf.slice(0, sep));
          } catch (error) {
            e = error;
            return reject(e);
          }
          if (metadata.version === 2) {
            return resolve(metadata);
          } else {
            return reject(new Error('Uknown version: ' + metadata.version));
          }
        }
      };
      return input.on('readable', parser);
    });
  };

  nullDisposer = function() {
    return Promise.resolve(null);
  };

  hardlinkCopy = function(srcRoot, dstRoot, linkDests) {
    var dest, j, len, rsyncArgs;
    rsyncArgs = ['--timeout', '300', '--archive', '--delete'];
    for (j = 0, len = linkDests.length; j < len; j++) {
      dest = linkDests[j];
      rsyncArgs.push('--link-dest', dest);
    }
    rsyncArgs.push(srcRoot, dstRoot);
    rsync = spawn('rsync', rsyncArgs);
    return utils.waitPidAsync(rsync);
  };

  exports.applyDelta = function(srcImage) {
    var deltaStream, dstIdPromise, rootDirFunc;
    deltaStream = new stream.PassThrough();
    rootDirFunc = nullDisposer;
    if (srcImage != null) {
      rootDirFunc = docker.imageRootDirMounted.bind(docker);
    }
    dstIdPromise = parseDeltaStream(deltaStream).get('dockerConfig').bind(docker).then(docker.createEmptyImage);
    Promise.using(rootDirFunc(srcImage), function(srcRoot) {
      if (srcRoot != null) {
        srcRoot = path.join(srcRoot, '/');
      }
      return Promise.join(docker.infoAsync().get('Driver'), dstIdPromise, dstIdPromise.then(docker.imageRootDir), function(dockerDriver, dstId, dstRoot) {
        dstRoot = path.join(dstRoot, '/');
        return Promise["try"](function() {
          switch (dockerDriver) {
            case 'btrfs':
              if (srcRoot != null) {
                return btrfs.deleteSubvolAsync(dstRoot).then(function() {
                  return btrfs.snapshotSubvolAsync(srcRoot, dstRoot);
                });
              }
              break;
            case 'overlay':
              if (srcRoot != null) {
                return hardlinkCopy(srcRoot, dstRoot, [srcRoot]);
              }
              break;
            case 'aufs':
              if (srcRoot != null) {
                return docker.aufsDiffPaths(srcImage).then(function(diffPaths) {
                  return hardlinkCopy(srcRoot, dstRoot, diffPaths);
                });
              }
              break;
            default:
              throw new Error("Unsupported driver " + dockerDriver);
          }
        }).then(function() {
          var rsyncArgs;
          rsyncArgs = ['--timeout', '300', '--archive', '--delete', '--read-batch', '-', dstRoot];
          rsync = spawn('rsync', rsyncArgs);
          rsync.stdout.on('data', function(data) {
            return console.log("rsync stdout: " + data);
          });
          rsync.stderr.on('data', function(data) {
            return console.log("rsync stderr: " + data);
          });
          deltaStream.pipe(rsync.stdin);
          return utils.waitPidAsync(rsync);
        }).then(function() {
          return utils.waitPidAsync(spawn('sync'));
        }).then(function() {
          return deltaStream.emit('id', dstId);
        });
      })["catch"](function(e) {
        var ref;
        if (ref = e != null ? e.code : void 0, indexOf.call(DELTA_OUT_OF_SYNC_CODES, ref) >= 0) {
          deltaStream.emit('error', new OutOfSyncError('Incompatible image'));
        } else {
          deltaStream.emit('error', e);
        }
        return dstIdPromise.then(function(dstId) {
          return docker.getImage(dstId).removeAsync()["catch"](function(e) {
            return deltaStream.emit('error', e);
          });
        });
      });
    });
    return deltaStream;
  };

}).call(this);
